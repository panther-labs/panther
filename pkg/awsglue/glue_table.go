package awsglue

/**
 * Copyright 2020 Panther Labs Inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import (
	"fmt"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/awserr"
	"github.com/aws/aws-sdk-go/service/glue"
	"github.com/aws/aws-sdk-go/service/glue/glueiface"
	"github.com/pkg/errors"
)

const (
	LogS3Prefix         = "logs"
	RuleMatchesS3Prefix = "rules"

	LogTableDatabaseName         = "panther_tables"
	RuleMatchesTableDatabaseName = "panther_rule_matches"
	LogTablesDatabaseDescription = "Holds tables generated by Panther data processing"

	LogViewsDatabaseName        = "panther_views"
	LogViewsDatabaseDescription = "Holds views useful for querying Panther tables"

	GlueTimestampType = "timestamp" // type in GlueTableMetadata tables for timestamps that we will re-map Go times
)



// Meta data about GlueTableMetadata table over parser data written to S3
// NOTE: this struct has all accessor behind functions to allow a lazy evaluation
//       so the cost of creating the schema is only when actually needing this information.
type GlueTableMetadata struct {
	databaseName string
	tableName    string
	description  string
	s3Prefix     string           // All data for this table are stored in this S3 prefix
	timebin      GlueTableTimebin // at what time resolution is this table partitioned
	timeUnpadded bool             // if true, do not zero pad partition time values
	eventStruct  interface{}      // object used to infer columns
}

func (gm *GlueTableMetadata) DatabaseName() string {
	return gm.databaseName
}

func (gm *GlueTableMetadata) TableName() string {
	return gm.tableName
}

func (gm *GlueTableMetadata) Description() string {
	return gm.description
}

func (gm *GlueTableMetadata) S3Prefix() string {
	return gm.s3Prefix
}

func (gm *GlueTableMetadata) Timebin() GlueTableTimebin {
	return gm.timebin
}

func (gm *GlueTableMetadata) EventStruct() interface{} {
	return gm.eventStruct
}

// Based on Timebin(), return an S3 prefix for objects
func (gm *GlueTableMetadata) PartitionPrefix(t time.Time) (prefix string) {
	partitionValues := gm.PartitionValues(t)
	prefix = gm.s3Prefix
	switch gm.timebin {
	case GlueTableHourly:
		prefix += fmt.Sprintf("year=%s/month=%s/day=%s/hour=%s/",
			*partitionValues[0], *partitionValues[1], *partitionValues[2], *partitionValues[3])
	case GlueTableDaily:
		prefix += fmt.Sprintf("year=%s/month=%s/day=%s/",
			*partitionValues[0], *partitionValues[1], *partitionValues[2])
	case GlueTableMonthly:
		prefix += fmt.Sprintf("year=%s/month=%s/",
			*partitionValues[0], *partitionValues[1])
	}
	return
}

type Partition struct {
	Name string
	Type string
}

func (gm *GlueTableMetadata) PartitionKeys() (partitions []Partition) {
	partitions = []Partition{
		{Name: "year", Type: "int"},
	}

	if gm.Timebin() >= GlueTableMonthly {
		partitions = append(partitions, Partition{Name: "month", Type: "int"})
	}
	if gm.Timebin() >= GlueTableDaily {
		partitions = append(partitions, Partition{Name: "day", Type: "int"})
	}
	if gm.Timebin() >= GlueTableHourly {
		partitions = append(partitions, Partition{Name: "hour", Type: "int"})
	}
	return partitions
}

// Based on Timebin(), return an []*string values (used for GlueTableMetadata APIs)
func (gm *GlueTableMetadata) PartitionValues(t time.Time) (values []*string) {
	var intFormat string

	if gm.timeUnpadded {
		intFormat = "%d"
	} else {
		intFormat = "%02d"
	}

	values = []*string{aws.String(fmt.Sprintf("%d", t.Year()))} // always unpadded

	if gm.timebin >= GlueTableMonthly {
		values = append(values, aws.String(fmt.Sprintf(intFormat, t.Month())))
	}
	if gm.timebin >= GlueTableDaily {
		values = append(values, aws.String(fmt.Sprintf(intFormat, t.Day())))
	}
	if gm.timebin >= GlueTableHourly {
		values = append(values, aws.String(fmt.Sprintf(intFormat, t.Hour())))
	}
	return
}



func NewLogTableMetadata(logType, description string, eventStruct interface{}) *GlueTableMetadata {
	// clean table name to make sql friendly
	tableName := strings.Replace(logType, ".", "_", -1) // no '.'
	tableName = strings.ToLower(logType)

	s3Prefix := LogS3Prefix + "/" + tableName
	if s3Prefix[len(s3Prefix)-1] != '/' { // ensure last char is '/'
		s3Prefix += "/"
	}

	return &GlueTableMetadata{
		databaseName: LogTableDatabaseName,
		tableName:    tableName,
		description:  description,
		s3Prefix:     s3Prefix,
		timebin:      GlueTableHourly,
		timeUnpadded: false,
		eventStruct:  eventStruct,
	}
}


// CreateJSONPartition creates a new JSON partition in a GlueTableMetadata table. If the partition already exists, it doesn't perform an operation.
func (gm *GlueTableMetadata) CreateJSONPartition(client glueiface.GlueAPI, t time.Time) error {
	partitionPrefix := "s3://" +  gm.PartitionPrefix(t)

	partitionInput := &glue.PartitionInput{
		Values:            gm.PartitionValues(t),
		StorageDescriptor: getJSONPartitionDescriptor(partitionPrefix),
	}
	input := &glue.CreatePartitionInput{
		DatabaseName:   aws.String(gm.databaseName),
		TableName:      aws.String(gm.tableName),
		PartitionInput: partitionInput,
	}
	_, err := client.CreatePartition(input)
	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			if awsErr.Code() == "AlreadyExistsException" {
				return nil
			}
		}
		return errors.Wrap(err, "failed to create new JSON partition")
	}

	return err
}

// CreateJSONPartition creates a new JSON partition in a GlueTableMetadata table. If the partition already exists, it doesn't perform an operation.
func (gm *GlueTableMetadata) Tsa(client glueiface.GlueAPI, t time.Time) error {
	partitionPrefix := "s3://" +  gm.PartitionPrefix(t)

	partitionInput := &glue.PartitionInput{
		Values:            gm.PartitionValues(t),
		StorageDescriptor: getJSONPartitionDescriptor(partitionPrefix),
	}
	input := &glue.CreatePartitionInput{
		DatabaseName:   aws.String(gm.databaseName),
		TableName:      aws.String(gm.tableName),
		PartitionInput: partitionInput,
	}
	_, err := client.CreatePartition(input)
	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			if awsErr.Code() == "AlreadyExistsException" {
				return nil
			}
		}
		return errors.Wrap(err, "failed to create new JSON partition")
	}

	return err
}

func (gm *GlueTableMetadata) GetPartition(client glueiface.GlueAPI, t time.Time) (output *glue.GetPartitionOutput, err error) {
	input := &glue.GetPartitionInput{
		DatabaseName:    aws.String(gm.databaseName),
		TableName:       aws.String(gm.tableName),
		PartitionValues: gm.PartitionValues(t),
	}
	return client.GetPartition(input)
}

func (gm *GlueTableMetadata) DeletePartition(client glueiface.GlueAPI, t time.Time) (output *glue.DeletePartitionOutput, err error) {
	input := &glue.DeletePartitionInput{
		DatabaseName:    aws.String(gm.databaseName),
		TableName:       aws.String(gm.tableName),
		PartitionValues: gm.PartitionValues(t),
	}
	return client.DeletePartition(input)
}

// SyncPartition deletes and re-creates a partition using the latest table schema. Used when schemas change.
func (gm *GlueTableMetadata) SyncPartition(client glueiface.GlueAPI, t time.Time) error {
	_, err := gm.DeletePartition(client, t)
	if err != nil {
		if awsErr, ok := err.(awserr.Error); !ok || awsErr.Code() != "EntityNotFoundException" {
			return errors.Wrapf(err, "delete partition for %s.%s at %v failed", gm.DatabaseName(), gm.TableName(), t)
		}
	}
	err = gm.CreateJSONPartition(client, t)
	if err != nil {
		return errors.Wrapf(err, "create partition for %s.%s at %v failed", gm.DatabaseName(), gm.TableName(), t)
	}
	return nil
}

func getJSONPartitionDescriptor(s3Path string) *glue.StorageDescriptor {
	return &glue.StorageDescriptor{
		InputFormat:  aws.String("org.apache.hadoop.mapred.TextInputFormat"),
		OutputFormat: aws.String("org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat"),
		SerdeInfo: &glue.SerDeInfo{
			SerializationLibrary: aws.String("org.openx.data.jsonserde.JsonSerDe"),
			Parameters: map[string]*string{
				"serialization.format": aws.String("1"),
				"case.insensitive":     aws.String("TRUE"), // treat as lower case
			},
		},
		Location: aws.String(s3Path),
	}
}
